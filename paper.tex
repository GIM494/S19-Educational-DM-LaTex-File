\documentclass[12pt]{article}
\usepackage{amsmath}%
\usepackage{amssymb}%
\usepackage{multicol}
\usepackage{graphicx,epsfig}%
\usepackage[margin=1in]{geometry}
\usepackage{rotating}%
\usepackage{url}
\usepackage[backend=bibtex, citestyle=ieee]{biblatex}
\bibliography{paper}
\usepackage{epsfig}%
\usepackage{epstopdf}%
\usepackage{varwidth}
\usepackage{lscape}%
\usepackage{color}
\usepackage[hang,flushmargin]{footmisc} 
\pdfminorversion 3
\usepackage{pbox}

\newcommand{\hilt}[1]{\colorbox{green}{#1}}
\usepackage{setspace}
\usepackage{adjustbox}
\def\x{\mathbf{x}}

\newcommand\blfootnote[1]{%
  \begingroup
  \renewcommand\thefootnote{}\footnote{#1}%
  \addtocounter{footnote}{-1}%
  \endgroup
}

\newcommand{\tcr}{\textcolor{red}}
\newcommand{\tcb}{\textcolor{blue}}
\newcommand\tab[1][1cm]{\hspace*{#1}}

\DeclareMathOperator*{\argmin}{argmin} 
\renewcommand{\baselinestretch}{1.5}
\usepackage{tabularx}

\usepackage{bibentry}

\title{S19: REU Research Document}
\author{Emily Slaughter, Gennie Mansi }

\begin{document}

\maketitle

\clearpage

\tableofcontents

\clearpage

%%%%%%%%%%%%%%%%%%%
\section{Abstract}



\clearpage
%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Proper documentation forms an integral part of developing and maintaining software, especially given the increasing size of code bases and the prevalence of temporally and spatially dispersed teams. As code is written and a project develops, various design decisions are made, which impact both existing and future code. Documentation of design decisions and the rationale behind those decisions is dependent on the developer and is often recorded or dispersed between a formal document and comments in the code itself. However, documentation is often not written, read, or updated, and coworkers are not always a reliable resource. Ko et al found that during software development, the information most frequently sought by developers was about artifacts and coworkers, and furthermore that tasks were often deferred because the only source of knowledge was coworkers who were unavailable \cite{KoEtAl2007}. Lack of documentation ultimately causes newcomers to a project to depend largely on the code rather than existing documentation to understand such project-specific design rules.

We are working to create a tool that enables mixed human-AI authoring of code patterns, thus facilitating active documentation and maintenance of code and allowing developers to efficiently and accurately apply and maintain a unified set of design rules. There are an exponential number of patterns that could be found in a given code base, and some rules have greater relevance than others. Finding an excessive number of non-existent rules or missing important or obvious rules would discourage developers from using the tool to document their code. Hence the crux of the problem, and therefore our focus this summer, is to intelligently determine which patterns in a codebase of any language should be used to train the machine learning algorithm.

There are essentially three distinct situations in which such a tool may be used. Each situation offers its own challenges and requires different operational capabilities on the part of the tool. The first situation is that in which a developer who is experienced with a given code base is trying to author rules or verify that certain rules have been followed. The second situation is one in which a developer who is not as familiar with a code base but still has some base knowledge of its contents and general design is trying to explore possible rules. It may be the case that the developer just needs to see a rule in order to recognize is correctness or applicability, but she on her own might not be able to produce an accurate rule. A developer in this situation may be able to provide useful feedback on which rules are helpful and relevant to a given code base. The final situation is that of a developer who is not familiar with a code base at all and needs rule suggestions both to understand the structure of the code and to ensure she adheres to its standards. In such a situation, the developer may even be interested in looking for examples on what kind of design decisions were previously made.

ActiveDocumentation is a plug-in for IntelliJ IDEA that can be used to author rules and to view examples that adhere to or violate rules in a given code base in real time \cite{MehrpurEtAl2019}. In the first situation, a tool like the ActiveDocumentation plug-in would be able to help the developer author, check, and fix rules, efficiently and in real time. The second and third cases, however, provide more interesting challenges. LaToza et al explored finding design patterns in an HTML document in order to perform code prediction \cite{LaTozaEtAl2019}. However, they did not try to identify design rules that might explain that pattern nor did they integrate information from sources outside of the code base such as cursor information or search history.

We seek to develop a tool that combines the rule-authoring and live-update features from ActiveDocumentation with pattern finding properties. We also wish to explore how information from outside of the code base could be used to inform what patterns are identified. Since ActiveDocumentation can help those who understand a code base write rules and check for correct examples and violations of that rule, a natural next step is to work on a tool for a developer who might have some knowledge about a code base that is not comprehensive (i.e. the second situation). This forms a natural bridge between a tool that is used by a developer who simply needs to author rules for a code base she is familiar with (the first situation), and a tool that is used by someone who is completely unfamiliar with a code base and cannot provide helpful or accurate feedback about suggested rules. Thus, in this paper, we focus on developing a tool to help a developer who finds herself in the second situation.



\clearpage


%%%%%%%%%%%%%%%%%%%
\section{Tool design and development}
There are several major considerations even when we narrow our focus to a developer in the second situation. These considerations divide generally into considerations of what kinds of data are available and helpful for suggesting rules and how these kinds of data can be utilized to make relevant design rule suggestions.

There are sundry sources of data available that provide information about the code base and sections in which the developer might be most interested. The most obvious source of information about the code is the code itself. Using a tool called srcML, the code can be put into XML format that can then be searched using XPath. Thus we can identify all kinds of information about the code itself, including function and class names and declarations, member variables, and relationships between classes like child and parent classes. Information is also available from the IDE itself. Such information can include the cursor's current and previous locations, the user's search history, and which file windows are currently open in the project. Finally, the tool itself could be a possible source of information. For example, information about existing rules may be used to help improve the relevancy of the design rules presented to the developer.

When considering what makes a rule relevant and how to automate the process of finding relevant rules, it's important to question how developers currently find relevant rules. According to a degree-of-interest (DOI) model developed by Fritz et al, a developer's activity can in fact be used as a proxy for their knowledge of code. Initially, the DOI model was defined in terms of two components: frequency and recency. The frequency with which a developer interacted with an element increased that element's DOI value, while the recency with which a developer interacted with an element decayed that element's DOI value. It was found that in addition to frequency and recency, however, other factors such as authorship of code, authorship duration, code stability, existence of code patterns, role of elements in a program, task locality, work experience, and type of activity are all important factors that affect a developer's program structure knowledge as well \cite{FritzEtAl2007}.

There are a couple of approaches that could be taken to ensure relevant design rule suggestions. One way of viewing this challenge is to view it as a source of natural language programming (NLP) problem. One group of researchers were trying to improve code suggestions and viewed their challenge as analogous to a more traditional NLP problem of trying to fill in a missing word in a sentence. They developed a statistical language model to aid in providing suggestions for different code snippets \cite{RaychevEtAl2014}. We could think of our challenge as analogous to an NLP problem that aims to outline a corpus of text or maybe, even more abstractly, find rhetorical devices in a text. Alternatively, we could simply rely more on traditional papers and research that have been conducted in this area that do not rely on NLP techniques to provide solutions. Both perspectives may prove useful in the initial stages of research that entail exploring different ways that information is stored and what information about developer activity has seemed most helpful in designing related tools.






\clearpage
%%%%%%%%%%%%%%%%%%%
\section{Product description}



\clearpage


%%%%%%%%%%%%%%%%%%%
\section{Methodology}



\clearpage

%%%%%%%%%%%%%%%%%%%
\section{User study}



\clearpage

%%%%%%%%%%%%%%%%%%%
\section{Related works}

Through what is called implicit group memory, Hipikat is a client-server system that automates the mentor-like relationship that develops between developers who are new to a project and senior developers who watch over the newcomers and pass down knowledge. Hipikat learn from four types of artifacts and communications stored in a project's history: bug and feature descriptions, source file revisions, messages posted on developer forums, and other project documents. Artifacts may be queried, and the artifact database may be searched \cite{CubranicAndMurphy2003}.

Mylar is a tool that exists within the Eclipse IDE and encodes a programmer's activity with code into a degree-of-interest model that can then be used to filter information in a program that may be related to the task that a developer is completing. Programmer activity is defined as selections and editing of code. This model focuses on individual program elements without taking into account the possible structural relationships that may exist between program elements \cite{KerstenEtAl2005}.




\clearpage

%%%%%%%%%%%%%%%%%%%
\section{Discussion}



\clearpage
%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%
\section{References}

\printbibliography

\end{document}